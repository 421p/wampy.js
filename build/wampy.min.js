/**
 * Project: wampy.js
 *
 * https://github.com/KSDaemon/wampy.js
 *
 * A lightweight client-side implementation of
 * WAMP (The WebSocket Application Messaging Protocol v2)
 * http://wamp.ws
 *
 * Provides asynchronous RPC/PubSub over WebSocket.
 *
 * Copyright 2014 KSDaemon. Licensed under the MIT License.
 * See @license text at http://www.opensource.org/licenses/mit-license.php
 *
 */
// Module boilerplate to support browser globals and browserify and AMD.
("function"==typeof define?function(a){define("Wampy",a)}:"object"==typeof exports?function(a){module.exports=a()}:function(a){this.Wampy=a()})(function(){function a(a){var b,c;// no scheme, but port is specified
// just path on current server
// domain
return a?/^ws(s)?:\/\//.test(a)?a:/:\d{1,5}/.test(a)?(b="https:"===window.location.protocol?"wss://":"ws://",b+a):"/"===a[0]?(b="https:"===window.location.protocol?"wss://":"ws://",c=""!==window.location.port?":"+window.location.port:"",b+window.location.hostname+c+a):(b="https:"===window.location.protocol?"wss://":"ws://",b+a):(b="https:"===window.location.protocol?"wss://":"ws://",c=""!==window.location.port?":"+window.location.port:"",b+window.location.hostname+c+"/ws")}function b(a){return/^ws(s)?:\/\//.test(a)?a:null}function c(c,d,e){var g=f?b(c):a(c);// we're in browser
return g?e?new e(g,d):f?null:"WebSocket"in root?new window.WebSocket(g,d):"MozWebSocket"in root?new window.MozWebSocket(g,d):null:null}var d={HELLO:1,WELCOME:2,ABORT:3,CHALLENGE:4,AUTHENTICATE:5,GOODBYE:6,HEARTBEAT:7,ERROR:8,PUBLISH:16,PUBLISHED:17,SUBSCRIBE:32,SUBSCRIBED:33,UNSUBSCRIBE:34,UNSUBSCRIBED:35,EVENT:36,CALL:48,CANCEL:49,RESULT:50,REGISTER:64,REGISTERED:65,UNREGISTER:66,UNREGISTERED:67,INVOCATION:68,INTERRUPT:69,YIELD:70},e={SUCCESS:{code:0,description:"Success!"},URI_ERROR:{code:1,description:"Topic URI doesn't meet requirements!"},NO_BROKER:{code:2,description:"Server doesn't provide broker role!"},NO_CALLBACK_SPEC:{code:3,description:"No required callback function specified!"},INVALID_PARAM:{code:4,description:"Invalid parameter(s) specified!"},NON_EXIST_SUBSCRIBE_CONFIRM:{code:5,description:"Received subscribe confirmation to non existent subscription!"},NON_EXIST_SUBSCRIBE_ERROR:{code:6,description:"Received error for non existent subscription!"},NON_EXIST_UNSUBSCRIBE:{code:7,description:"Trying to unsubscribe from non existent subscription!"},NON_EXIST_SUBSCRIBE_UNSUBSCRIBED:{code:8,description:"Received unsubscribe confirmation to non existent subscription!"},NON_EXIST_PUBLISH_ERROR:{code:9,description:"Received error for non existent publication!"},NON_EXIST_PUBLISH_PUBLISHED:{code:10,description:"Received publish confirmation for non existent publication!"},NON_EXIST_SUBSCRIBE_EVENT:{code:11,description:"Received event for non existent subscription!"},NO_DEALER:{code:12,description:"Server doesn't provide dealer role!"},NON_EXIST_CALL_RESULT:{code:13,description:"Received rpc result for non existent call!"},NON_EXIST_CALL_ERROR:{code:14,description:"Received rpc call error for non existent call!"},RPC_ALREADY_REGISTERED:{code:15,description:"RPC already registered!"},NON_EXIST_RPC_REG:{code:16,description:"Received rpc registration confirmation for non existent rpc!"},NON_EXIST_RPC_UNREG:{code:17,description:"Received rpc unregistration for non existent rpc!"},NON_EXIST_RPC_ERROR:{code:18,description:"Received error for non existent rpc!"},NON_EXIST_RPC_INVOCATION:{code:19,description:"Received invocation for non existent rpc!"},NON_EXIST_RPC_REQ_ID:{code:20,description:"No RPC calls in action with specified request ID!"},NO_REALM:{code:21,description:"No realm specified!"},NO_WS_OR_URL:{code:22,description:"No websocket provided or URL specified is incorrect!"}},f="object"==typeof process&&"[object process]"===Object.prototype.toString.call(process),g=function(a,b){switch(/**
         * Wampy version
         * @type {string}
         * @private
         */
this.version="v2.0.0",/**
         * WS Url
         * @type {string}
         * @private
         */
this._url="string"==typeof arguments[0]?a:null,/**
         * WS protocols
         * @type {Array}
         * @private
         */
this._protocols=["wamp.2.json"],/**
         * WAMP features, supported by Wampy
         * @type {object}
         * @private
         */
this._wamp_features={agent:"Wampy.js "+this.version,roles:{publisher:{features:{subscriber_blackwhite_listing:!0,publisher_exclusion:!0,publisher_identification:!0}},subscriber:{},caller:{features:{callee_blackwhite_listing:!0,caller_exclusion:!0,caller_identification:!0,progressive_call_results:!0,call_canceling:!0}},callee:{features:{caller_identification:!0}}}},/**
         * Internal cache for object lifetime
         * @type {Object}
         * @private
         */
this._cache={/**
             * WAMP Session ID
             * @type {string}
             */
sessionId:null,/**
             * Server WAMP roles and features
             */
server_wamp_features:{roles:{}},/**
             * Are we in state of saying goodbye
             * @type {boolean}
             */
isSayingGoodbye:!1,/**
             * Status of last operation
             */
opStatus:{code:0,description:"Success!",reqId:0},/**
             * Timer for reconnection
             * @type {null}
             */
timer:null,/**
             * Reconnection attempts
             * @type {number}
             */
reconnectingAttempts:0},/**
         * WebSocket object
         * @type {Object}
         * @private
         */
this._ws=null,/**
         * Internal queue for websocket requests, for case of disconnect
         * @type {Array}
         * @private
         */
this._wsQueue=[],/**
         * Internal queue for wamp requests
         * @type {object}
         * @private
         */
this._requests={},/**
         * Stored RPC
         * @type {object}
         * @private
         */
this._calls={},/**
         * Stored Pub/Sub
         * @type {object}
         * @private
         */
this._subscriptions={},/**
         * Stored Pub/Sub topics
         * @type {Array}
         * @private
         */
this._subsTopics=[],/**
         * Stored RPC Registrations
         * @type {object}
         * @private
         */
this._rpcRegs={},/**
         * Stored RPC names
         * @type {Array}
         * @private
         */
this._rpcNames=[],/**
         * Options hash-table
         * @type {Object}
         * @private
         */
this._options={/**
             * Logging
             * @type {boolean}
             */
debug:!1,/**
             * Reconnecting flag
             * @type {boolean}
             */
autoReconnect:!0,/**
             * Reconnecting interval (in ms)
             * @type {number}
             */
reconnectInterval:2e3,/**
             * Maximum reconnection retries
             * @type {number}
             */
maxRetries:25,/**
             * Message serializer
             * @type {string}
             */
transportEncoding:"json",/**
             * WAMP Realm to join
             * @type {string}
             */
realm:null,/**
             * onConnect callback
             * @type {function}
             */
onConnect:null,/**
             * onClose callback
             * @type {function}
             */
onClose:null,/**
             * onError callback
             * @type {function}
             */
onError:null,/**
             * onReconnect callback
             * @type {function}
             */
onReconnect:null,/**
             * User provided WebSocket class
             * @type {function}
             */
ws:null,/**
             * User provided msgpack class
             * @type {function}
             */
msgpackCoder:null},arguments.length){case 1:"string"!=typeof arguments[0]&&(this._options=this._merge(this._options,arguments[0]));break;case 2:this._options=this._merge(this._options,b)}this.connect()};/* Internal utils methods */
/**
     * Internal logger
     * @param obj
     * @private
     */
/**
     * Get the new unique request id
     * @returns {number}
     * @private
     */
/**
     * Merge argument objects into one
     * @returns {Object}
     * @private
     */
/**
     * Check if value is array
     * @param obj
     * @returns {boolean}
     * @private
     */
/**
     * Check if value is object literal
     * @param obj
     * @returns {boolean}
     * @private
     */
/**
     * Fix websocket protocols based on options
     * @private
     */
/**
     * Validate uri
     * @param {string} uri
     * @returns {boolean}
     * @private
     */
/**
     * Encode WAMP message
     * @param {Array} msg
     * @returns {*}
     * @private
     */
/**
     * Decode WAMP message
     * @param  msg
     * @returns {array}
     * @private
     */
/**
     * Send encoded message to server
     * @param {Array} msg
     * @private
     */
/**
     * Reset internal state and cache
     * @private
     */
/**
     * Initialize internal websocket callbacks
     * @private
     */
/* Wampy public API */
/**
     * Get or set Wampy options
     *
     * To get options - call without parameters
     * To set options - pass hash-table with options values
     *
     * @param {object} opts
     * @returns {*}
     */
/**
     * Get the status of last operation
     *
     * @returns {code, description}
     *      code: 0 - if operation was successful
     *      code > 0 - if error occurred
     *      description contains details about error
     *      reqId: last send request ID
     */
/**
     * Get the WAMP Session ID
     *
     * @returns Session ID
     */
/**
     * Connect to server
     * @param {string} url New url (optional)
     * @returns {Wampy}
     */
/**
     * Disconnect from server
     * @returns {Wampy}
     */
/**
     * Abort WAMP session establishment
     *
     * @returns {Wampy}
     */
/**
     * Subscribe to a topic on a broker
     *
     * @param {string} topicURI
     * @param {function|object} callbacks - if it is a function - it will be treated as published event callback
     *                          or it can be hash table of callbacks:
     *                          { onSuccess: will be called when subscribe would be confirmed
     *                            onError: will be called if subscribe would be aborted
     *                            onEvent: will be called on receiving published event }
     *
     * @returns {Wampy}
     */
/**
     * Unsubscribe from topic
     * @param {string} topicURI
     * @param {function|object} callbacks - if it is a function - it will be treated as
     *                          published event callback to remove or it can be hash table of callbacks:
     *                          { onSuccess: will be called when unsubscribe would be confirmed
     *                            onError: will be called if unsubscribe would be aborted
     *                            onEvent: published event callback to remove }
     * @returns {Wampy}
     */
/**
     * Publish a event to topic
     * @param {string} topicURI
     * @param {string|number|Array|object} payload - optional parameter.
     * @param {object} callbacks - optional hash table of callbacks:
     *                          { onSuccess: will be called when publishing would be confirmed
     *                            onError: will be called if publishing would be aborted }
     * @param {object} advancedOptions - optional parameter. Must include any or all of the options:
     *                          { exclude: integer|array WAMP session id(s) that won't receive a published event,
     *                                      even though they may be subscribed
     *                            eligible: integer|array WAMP session id(s) that are allowed
     *                                      to receive a published event
     *                            exclude_me: bool flag of receiving publishing event by initiator
     *                            disclose_me: bool flag of disclosure of publisher identity (its WAMP session ID)
     *                                      to receivers of a published event }
     * @returns {Wampy}
     */
/**
     * Remote Procedure Call
     * @param {string} topicURI
     * @param {string|number|Array|object} payload - can be either a value of any type or null
     * @param {function|object} callbacks - if it is a function - it will be treated as result callback function
     *                          or it can be hash table of callbacks:
     *                          { onSuccess: will be called with result on successful call
     *                            onError: will be called if invocation would be aborted }
     * @param {object} advancedOptions - optional parameter. Must include any or all of the options:
     *                          { exclude: integer|array WAMP session id(s) providing an explicit list of
     *                                  (potential) Callees that a call won't be forwarded to, even though
     *                                  they might be registered
     *                            eligible: integer|array WAMP session id(s) providing an explicit list of
     *                                  (potential) Callees that are (potentially) forwarded the call issued
     *                            exclude_me: bool flag of potentially forwarding call to caller
     *                                  if he is registered as callee
     *                            disclose_me: bool flag of disclosure of Caller identity (WAMP session ID)
     *                                  to endpoints of a routed call
     *                            receive_progress: bool flag for receiving progressive results. In this case
     *                                  onSuccess function will be called every time on receiving result }
     * @returns {Wampy}
     */
/**
     * RPC invocation cancelling
     *
     * @param {int} reqId RPC call request ID
     * @param {function|object} callbacks - if it is a function - it will be called if successfully
     *                          sent canceling message or it can be hash table of callbacks:
     *                          { onSuccess: will be called if successfully sent canceling message
     *                            onError: will be called if some error occurred }
     * @param {object} advancedOptions - optional parameter. Must include any or all of the options:
     *                          { mode: string|one of the possible modes:
     *                                  "skip" | "kill" | "killnowait". Skip is default.
      *                          }
     *
     * @returns {Wampy}
     */
/**
     * RPC registration for invocation
     * @param {string} topicURI
     * @param {function|object} callbacks - if it is a function - it will be treated as rpc itself
     *                          or it can be hash table of callbacks:
     *                          { rpc: registered procedure
     *                            onSuccess: will be called on successful registration
     *                            onError: will be called if registration would be aborted }
     * @returns {Wampy}
     */
/**
     * RPC unregistration for invocation
     * @param {string} topicURI
     * @param {function|object} callbacks - if it is a function, it will be called on successful unregistration
     *                          or it can be hash table of callbacks:
     *                          { onSuccess: will be called on successful unregistration
     *                            onError: will be called if unregistration would be aborted }
     * @returns {Wampy}
     */
return g.prototype._log=function(){this._options.debug},g.prototype._getReqId=function(){var a;do/* Lua (and cjson) outputs big numbers in scientific notation :(
             * Need to find a way of fixing that
             * For now, i think it's not a big problem to reduce range.
             */
//          reqId = Math.floor(Math.random() * 9007199254740992);
a=Math.floor(1e14*Math.random());while(a in this._requests);return a},g.prototype._merge=function(){var a,b,c={},d=arguments.length;for(a=0;d>a;a++)for(b in arguments[a])c[b]=arguments[a][b];return c},g.prototype._isArray=function(a){return!!a&&a.constructor===Array},g.prototype._isPlainObject=function(a){return!!a&&a.constructor===Object},g.prototype._setWsProtocols=function(){this._options.msgpackCoder&&("msgpack"===this._options.transportEncoding?this._protocols=["wamp.2.msgpack","wamp.2.json"]:this._protocols=["wamp.2.json","wamp.2.msgpack"])},g.prototype._validateURI=function(a){var b=/^([0-9a-zA-Z_]{2,}\.)*([0-9a-zA-Z_]{2,})$/;return b.test(a)&&0!==a.indexOf("wamp")?!0:!1},g.prototype._encode=function(a){if("msgpack"!==this._options.transportEncoding||!this._options.msgpackCoder)return JSON.stringify(a);try{return this._options.msgpackCoder.encode(a)}catch(b){throw new Error("[wampy] msgpack encode exception!")}},g.prototype._decode=function(a){if("msgpack"!==this._options.transportEncoding||!this._options.msgpackCoder)return JSON.parse(a);try{return this._options.msgpackCoder.decode(a)}catch(b){throw new Error("[wampy] msgpack decode exception!")}},g.prototype._send=function(a){if(a&&this._wsQueue.push(this._encode(a)),this._ws&&1===this._ws.readyState&&this._cache.sessionId)for(;this._wsQueue.length;)this._ws.send(this._wsQueue.shift())},g.prototype._resetState=function(){this._wsQueue=[],this._subscriptions={},this._subsTopics=[],this._requests={},this._calls={},this._rpcRegs={},this._rpcNames=[],
// Just keep attrs that are have to be present
this._cache={reconnectingAttempts:0}},g.prototype._initWsCallbacks=function(){var a=this;this._ws&&(this._ws.onopen=function(){a._wsOnOpen.call(a)},this._ws.onclose=function(b){a._wsOnClose.call(a,b)},this._ws.onmessage=function(b){a._wsOnMessage.call(a,b)},this._ws.onerror=function(b){a._wsOnError.call(a,b)})},g.prototype._wsOnOpen=function(){this._log("[wampy] websocket connected"),this._ws.protocol&&(this._options.transportEncoding=this._ws.protocol.split(".")[2]),"msgpack"===this._options.transportEncoding&&(this._ws.binaryType="arraybuffer"),
// WAMP SPEC: [HELLO, Realm|uri, Details|dict]
// Sending directly 'cause it's a hello msg and no sessionId check is needed
this._ws.send(this._encode([d.HELLO,this._options.realm,this._wamp_features]))},g.prototype._wsOnClose=function(){var a=this,b=f?global:window;this._log("[wampy] websocket disconnected"),
// Automatic reconnection
(this._cache.sessionId||this._cache.reconnectingAttempts)&&this._options.autoReconnect&&this._cache.reconnectingAttempts<this._options.maxRetries&&!this._cache.isSayingGoodbye?(this._cache.sessionId=null,this._cache.timer=b.setTimeout(function(){a._wsReconnect.call(a)},this._options.reconnectInterval)):(
// No reconnection needed or reached max retries count
this._options.onClose&&this._options.onClose(),this._resetState(),this._ws=null)},g.prototype._wsOnMessage=function(a){var b,c,f,g,h,i=this;switch(this._log("[wampy] websocket message received",a.data),b=this._decode(a.data),b[0]){case d.WELCOME:
// WAMP SPEC: [WELCOME, Session|id, Details|dict]
this._cache.sessionId=b[1],this._cache.server_wamp_features=b[2],this._cache.reconnectingAttempts?(
// There was reconnection
this._cache.reconnectingAttempts=0,
// Let's renew all previous state
this._renewSubscriptions(),this._renewRegistrations()):
// Firing onConnect event on real connection to WAMP server
this._options.onConnect&&this._options.onConnect(),
// Send local queue if there is something out there
this._send();break;case d.ABORT:
// WAMP SPEC: [ABORT, Details|dict, Reason|uri]
this._options.onError&&this._options.onError(b[1].message?b[1].message:b[2]),this._ws.close();break;case d.CHALLENGE:break;case d.GOODBYE:
// WAMP SPEC: [GOODBYE, Details|dict, Reason|uri]
this._cache.isSayingGoodbye||(// get goodbye, initiated by server
this._cache.isSayingGoodbye=!0,this._send([d.GOODBYE,{},"wamp.error.goodbye_and_out"])),this._cache.sessionId=null,this._ws.close();break;case d.HEARTBEAT:break;case d.ERROR:
// WAMP SPEC: [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict,
//             Error|uri, (Arguments|list, ArgumentsKw|dict)]
switch(b[1]){case d.SUBSCRIBE:case d.UNSUBSCRIBE:this._requests[b[2]]?(this._requests[b[2]].callbacks.onError&&this._requests[b[2]].callbacks.onError(b[4]),delete this._requests[b[2]]):this._cache.opStatus=e.NON_EXIST_SUBSCRIBE_ERROR;break;case d.PUBLISH:this._requests[b[2]]?(this._requests[b[2]].callbacks.onError&&this._requests[b[2]].callbacks.onError(b[4]),delete this._requests[b[2]]):this._cache.opStatus=e.NON_EXIST_PUBLISH_ERROR;break;case d.REGISTER:case d.UNREGISTER:
// WAMP SPEC: [ERROR, REGISTER, REGISTER.Request|id, Details|dict, Error|uri]
this._requests[b[2]]?(this._requests[b[2]].callbacks.onError&&this._requests[b[2]].callbacks.onError(b[4]),delete this._requests[b[2]]):this._cache.opStatus=e.NON_EXIST_RPC_ERROR;break;case d.INVOCATION:break;case d.CALL:if(this._calls[b[2]]){if(this._calls[b[2]].onError){switch(b.length){case 5:
// WAMP SPEC: [ERROR, CALL, CALL.Request|id, Details|dict, Error|uri]
g=null;break;case 6:
// WAMP SPEC: [ERROR, CALL, CALL.Request|id, Details|dict,
//             Error|uri, Arguments|list]
g=b[5];break;case 7:
// WAMP SPEC: [ERROR, CALL, CALL.Request|id, Details|dict,
//             Error|uri, Arguments|list, ArgumentsKw|dict]
g=b[6]}this._calls[b[2]].onError(g)}delete this._calls[b[2]]}else this._cache.opStatus=e.NON_EXIST_CALL_ERROR}break;case d.SUBSCRIBED:
// WAMP SPEC: [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
this._requests[b[1]]?(this._subscriptions[this._requests[b[1]].topic]=this._subscriptions[b[2]]={id:b[2],callbacks:[this._requests[b[1]].callbacks.onEvent]},this._subsTopics.push(this._requests[b[1]].topic),this._requests[b[1]].callbacks.onSuccess&&this._requests[b[1]].callbacks.onSuccess(),delete this._requests[b[1]]):this._cache.opStatus=e.NON_EXIST_SUBSCRIBE_CONFIRM;break;case d.UNSUBSCRIBED:
// WAMP SPEC: [UNSUBSCRIBED, UNSUBSCRIBE.Request|id]
this._requests[b[1]]?(c=this._subscriptions[this._requests[b[1]].topic].id,delete this._subscriptions[this._requests[b[1]].topic],delete this._subscriptions[c],f=this._subsTopics.indexOf(this._requests[b[1]].topic),f>=0&&this._subsTopics.splice(f,1),this._requests[b[1]].callbacks.onSuccess&&this._requests[b[1]].callbacks.onSuccess(),delete this._requests[b[1]]):this._cache.opStatus=e.NON_EXIST_SUBSCRIBE_UNSUBSCRIBED;break;case d.PUBLISHED:
// WAMP SPEC: [PUBLISHED, PUBLISH.Request|id, Publication|id]
this._requests[b[1]]?(this._requests[b[1]].callbacks&&this._requests[b[1]].callbacks.onSuccess&&this._requests[b[1]].callbacks.onSuccess(),delete this._requests[b[1]]):this._cache.opStatus=e.NON_EXIST_PUBLISH_PUBLISHED;break;case d.EVENT:if(this._subscriptions[b[1]]){switch(b.length){case 4:
// WAMP SPEC: [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict]
g=null;break;case 5:
// WAMP SPEC: [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
//             Details|dict, PUBLISH.Arguments|list]
g=b[4];break;case 6:
// WAMP SPEC: [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id,
//             Details|dict, PUBLISH.Arguments|list, PUBLISH.ArgumentKw|dict]
g=b[5]}for(f=this._subscriptions[b[1]].callbacks.length;f--;)this._subscriptions[b[1]].callbacks[f](g)}else this._cache.opStatus=e.NON_EXIST_SUBSCRIBE_EVENT;break;case d.RESULT:if(this._calls[b[1]]){switch(b.length){case 3:
// WAMP SPEC: [RESULT, CALL.Request|id, Details|dict]
g=null;break;case 4:
// WAMP SPEC: [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]
g=b[3];break;case 5:
// WAMP SPEC: [RESULT, CALL.Request|id, Details|dict,
//             YIELD.Arguments|list, YIELD.ArgumentsKw|dict]
g=b[4]}this._calls[b[1]].onSuccess(g),b[2].progress&&b[2].progress===!0||
// We receive final result (progressive or not)
delete this._calls[b[1]]}else this._cache.opStatus=e.NON_EXIST_CALL_RESULT;break;case d.REGISTER:
// WAMP SPEC:
break;case d.REGISTERED:
// WAMP SPEC: [REGISTERED, REGISTER.Request|id, Registration|id]
this._requests[b[1]]?(this._rpcRegs[this._requests[b[1]].topic]=this._rpcRegs[b[2]]={id:b[2],callbacks:[this._requests[b[1]].callbacks.rpc]},this._rpcNames.push(this._requests[b[1]].topic),this._requests[b[1]].callbacks&&this._requests[b[1]].callbacks.onSuccess&&this._requests[b[1]].callbacks.onSuccess(),delete this._requests[b[1]]):this._cache.opStatus=e.NON_EXIST_RPC_REG;break;case d.UNREGISTER:
// WAMP SPEC:
break;case d.UNREGISTERED:
// WAMP SPEC: [UNREGISTERED, UNREGISTER.Request|id]
this._requests[b[1]]?(c=this._rpcRegs[this._requests[b[1]].topic].id,delete this._rpcRegs[this._requests[b[1]].topic],delete this._rpcRegs[c],f=this._rpcNames.indexOf(this._requests[b[1]].topic),f>=0&&this._rpcNames.splice(f,1),this._requests[b[1]].callbacks&&this._requests[b[1]].callbacks.onSuccess&&this._requests[b[1]].callbacks.onSuccess(),delete this._requests[b[1]]):this._cache.opStatus=e.NON_EXIST_RPC_UNREG;break;case d.INVOCATION:if(this._rpcRegs[b[2]]){switch(b.length){case 4:
// WAMP SPEC: [INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict]
g=null;break;case 5:
// WAMP SPEC: [INVOCATION, Request|id, REGISTERED.Registration|id,
//             Details|dict, CALL.Arguments|list]
g=b[4];break;case 6:
// WAMP SPEC: [INVOCATION, Request|id, REGISTERED.Registration|id,
//             Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]
g=b[5]}Promise.resolve(this._rpcRegs[b[2]].callbacks[0](g)).then(function(a){
// WAMP SPEC: [YIELD, INVOCATION.Request|id, Options|dict, (Arguments|list, ArgumentsKw|dict)]
h=i._isArray(a)?[d.YIELD,b[1],{},a]:i._isPlainObject(a)?[d.YIELD,b[1],{},[],a]:"undefined"==typeof a?[d.YIELD,b[1],{}]:[d.YIELD,b[1],{},[a]],i._send(h)},function(a){i._send([d.ERROR,d.INVOCATION,b[1],{},"wamp.error.invocation_exception"])})}else
// WAMP SPEC: [ERROR, INVOCATION, INVOCATION.Request|id, Details|dict, Error|uri]
this._send([d.ERROR,d.INVOCATION,b[1],{},"wamp.error.no_such_procedure"]),this._cache.opStatus=e.NON_EXIST_RPC_INVOCATION;break;case d.INTERRUPT:
// WAMP SPEC:
break;case d.YIELD:}},g.prototype._wsOnError=function(a){this._log("[wampy] websocket error"),this._options.onError&&this._options.onError(a)},g.prototype._wsReconnect=function(){this._log("[wampy] websocket reconnecting..."),this._options.onReconnect&&this._options.onReconnect(),this._cache.reconnectingAttempts++,this._ws=c(this._url,this._protocols,this._options.ws),this._initWsCallbacks()},g.prototype._renewSubscriptions=function(){var a,b,c=this._subscriptions,d=this._subsTopics;for(this._subscriptions={},this._subsTopics=[],a=d.length;a--;)for(b=c[d[a]].callbacks.length;b--;)this.subscribe(d[a],c[d[a]].callbacks[b])},g.prototype._renewRegistrations=function(){var a,b=this._rpcRegs,c=this._rpcNames;for(this._rpcRegs={},this._rpcNames=[],a=c.length;a--;)this.register(c[a],{rpc:b[c[a]].callbacks[0]})},g.prototype.options=function(a){return"undefined"==typeof a?this._options:this._isPlainObject(a)?(this._options=this._merge(this._options,a),this):void 0},g.prototype.getOpStatus=function(){return this._cache.opStatus},g.prototype.getSessionId=function(){return this._cache.sessionId},g.prototype.connect=function(a){return a&&(this._url=a),this._options.realm?(this._setWsProtocols(),this._ws=c(this._url,this._protocols,this._options.ws),this._ws?this._initWsCallbacks():this._cache.opStatus=e.NO_WS_OR_URL):this._cache.opStatus=e.NO_REALM,this},g.prototype.disconnect=function(){
// need to send goodbye message to server
return this._cache.sessionId?(this._cache.isSayingGoodbye=!0,this._send([d.GOODBYE,{},"wamp.error.system_shutdown"])):this._ws&&this._ws.close(),this._cache.opStatus=e.SUCCESS,this},g.prototype.abort=function(){return this._cache.sessionId||1!==this._ws.readyState||(this._send([d.ABORT,{},"wamp.error.abort"]),this._cache.sessionId=null),this._ws.close(),this._cache.opStatus=e.SUCCESS,this},g.prototype.subscribe=function(a,b){var c;if(this._cache.sessionId&&!this._cache.server_wamp_features.roles.broker)return this._cache.opStatus=e.NO_BROKER,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this;if(!this._validateURI(a))return this._cache.opStatus=e.URI_ERROR,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this;if("function"==typeof b)b={onEvent:b};else if(!this._isPlainObject(b)||"undefined"==typeof b.onEvent)return this._cache.opStatus=e.NO_CALLBACK_SPEC,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this;// already have subscription to this topic
// There is no such callback yet
// no such subscription or processing unsubscribing
// WAMP SPEC: [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
return this._subscriptions[a]&&this._subscriptions[a].callbacks.length?(this._subscriptions[a].callbacks.indexOf(b.onEvent)<0&&this._subscriptions[a].callbacks.push(b.onEvent),b.onSuccess&&b.onSuccess()):(c=this._getReqId(),this._requests[c]={topic:a,callbacks:b},this._send([d.SUBSCRIBE,c,{},a])),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=c,this},g.prototype.unsubscribe=function(a,b){var c,f=-1;
// There are another callbacks for this topic
// WAMP_SPEC: [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
return this._cache.sessionId&&!this._cache.server_wamp_features.roles.broker?(this._cache.opStatus=e.NO_BROKER,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this):this._subscriptions[a]?(c=this._getReqId(),"undefined"==typeof b?(this._subscriptions[a].callbacks=[],b={}):"function"==typeof b?(f=this._subscriptions[a].callbacks.indexOf(b),b={}):b.onEvent&&"function"==typeof b.onEvent?f=this._subscriptions[a].callbacks.indexOf(b.onEvent):this._subscriptions[a].callbacks=[],f>=0&&this._subscriptions[a].callbacks.splice(f,1),this._subscriptions[a].callbacks.length?(this._cache.opStatus=e.SUCCESS,this):(this._requests[c]={topic:a,callbacks:b},this._send([d.UNSUBSCRIBE,c,this._subscriptions[a].id]),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=c,this)):(this._cache.opStatus=e.NON_EXIST_UNSUBSCRIBE,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this)},g.prototype.publish=function(a,b,c,f){var g,h,i={},j=!1;if(this._cache.sessionId&&!this._cache.server_wamp_features.roles.broker)return this._cache.opStatus=e.NO_BROKER,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;if(!this._validateURI(a))return this._cache.opStatus=e.URI_ERROR,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;if(this._isPlainObject(c)&&(i.acknowledge=!0),"undefined"!=typeof f&&(this._isPlainObject(f)?(f.exclude&&(this._isArray(f.exclude)?i.exclude=f.exclude:"number"==typeof f.exclude?i.exclude=[f.exclude]:j=!0),f.eligible&&(this._isArray(f.eligible)?i.eligible=f.eligible:"number"==typeof f.eligible?i.eligible=[f.eligible]:j=!0),f.hasOwnProperty("exclude_me")&&(i.exclude_me=f.exclude_me!==!1),f.hasOwnProperty("disclose_me")&&(i.disclose_me=f.disclose_me===!0)):j=!0,j))return this._cache.opStatus=e.INVALID_PARAM,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;switch(g=this._getReqId(),arguments.length){case 1:
// WAMP_SPEC: [PUBLISH, Request|id, Options|dict, Topic|uri]
h=[d.PUBLISH,g,i,a];break;case 2:
// WAMP_SPEC: [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list (, ArgumentsKw|dict)]
h=this._isArray(b)?[d.PUBLISH,g,i,a,b]:this._isPlainObject(b)?[d.PUBLISH,g,i,a,[],b]:[d.PUBLISH,g,i,a,[b]];break;default:this._requests[g]={topic:a,callbacks:c},
// WAMP_SPEC: [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list (, ArgumentsKw|dict)]
h=this._isArray(b)?[d.PUBLISH,g,i,a,b]:this._isPlainObject(b)?[d.PUBLISH,g,i,a,[],b]:[d.PUBLISH,g,i,a,[b]]}return this._send(h),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=g,this},g.prototype.call=function(a,b,c,f){var g,h,i={},j=!1;if(this._cache.sessionId&&!this._cache.server_wamp_features.roles.dealer)return this._cache.opStatus=e.NO_DEALER,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;if(!this._validateURI(a))return this._cache.opStatus=e.URI_ERROR,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;if("function"==typeof c)c={onSuccess:c};else if(!this._isPlainObject(c)||"undefined"==typeof c.onSuccess)return this._cache.opStatus=e.NO_CALLBACK_SPEC,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;if("undefined"!=typeof f&&(this._isPlainObject(f)?(f.exclude&&(this._isArray(f.exclude)?i.exclude=f.exclude:"number"==typeof f.exclude?i.exclude=[f.exclude]:j=!0),f.eligible&&(this._isArray(f.eligible)?i.eligible=f.eligible:"number"==typeof f.eligible?i.eligible=[f.eligible]:j=!0),f.hasOwnProperty("exclude_me")&&(i.exclude_me=f.exclude_me!==!1),f.hasOwnProperty("disclose_me")&&(i.disclose_me=f.disclose_me===!0),f.hasOwnProperty("receive_progress")&&(i.receive_progress=f.receive_progress===!0)):j=!0,j))return this._cache.opStatus=e.INVALID_PARAM,this._isPlainObject(c)&&c.onError&&c.onError(this._cache.opStatus.description),this;do g=this._getReqId();while(g in this._calls);
// WAMP SPEC: [CALL, Request|id, Options|dict, Procedure|uri, (Arguments|list, ArgumentsKw|dict)]
return this._calls[g]=c,h=null===b?[d.CALL,g,i,a]:this._isArray(b)?[d.CALL,g,i,a,b]:this._isPlainObject(b)?[d.CALL,g,i,a,[],b]:[d.CALL,g,i,a,[b]],this._send(h),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=g,this},g.prototype.cancel=function(a,b,c){var f={mode:"skip"};
// WAMP SPEC: [CANCEL, CALL.Request|id, Options|dict]
return this._cache.sessionId&&!this._cache.server_wamp_features.roles.dealer?(this._cache.opStatus=e.NO_DEALER,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this):a&&this._calls[a]?("undefined"!=typeof c&&this._isPlainObject(c)&&c.hasOwnProperty("mode")&&(f.mode=/skip|kill|killnowait/.test(c.mode)?c.mode:"skip"),this._send([d.CANCEL,a,f]),b.onSuccess&&b.onSuccess(),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=a,this):(this._cache.opStatus=e.NON_EXIST_RPC_REQ_ID,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this)},g.prototype.register=function(a,b){var c;if(this._cache.sessionId&&!this._cache.server_wamp_features.roles.dealer)return this._cache.opStatus=e.NO_DEALER,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this;if(!this._validateURI(a))return this._cache.opStatus=e.URI_ERROR,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this;if("function"==typeof b)b={rpc:b};else if(!this._isPlainObject(b)||"undefined"==typeof b.rpc)return this._cache.opStatus=e.NO_CALLBACK_SPEC,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this;// already have registration with such topicURI
// no such registration or processing unregistering
// WAMP SPEC: [REGISTER, Request|id, Options|dict, Procedure|uri]
return this._rpcRegs[a]&&this._rpcRegs[a].callbacks.length?(this._cache.opStatus=e.RPC_ALREADY_REGISTERED,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description)):(c=this._getReqId(),this._requests[c]={topic:a,callbacks:b},this._send([d.REGISTER,c,{},a]),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=c),this},g.prototype.unregister=function(a,b){var c;// there is such registration
// WAMP SPEC: [UNREGISTER, Request|id, REGISTERED.Registration|id]
// there is no registration with such topicURI
return this._cache.sessionId&&!this._cache.server_wamp_features.roles.dealer?(this._cache.opStatus=e.NO_DEALER,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this):this._validateURI(a)?("function"==typeof b&&(b={onSuccess:b}),this._rpcRegs[a]?(c=this._getReqId(),this._requests[c]={topic:a,callbacks:b},this._send([d.UNREGISTER,c,this._rpcRegs[a].id]),this._cache.opStatus=e.SUCCESS,this._cache.opStatus.reqId=c):(this._cache.opStatus=e.NON_EXIST_RPC_UNREG,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description)),this):(this._cache.opStatus=e.URI_ERROR,this._isPlainObject(b)&&b.onError&&b.onError(this._cache.opStatus.description),this)},g});
//# sourceMappingURL=wampy.min.js.map